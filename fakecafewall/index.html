<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Caf√© Wall Illusion - Three.js</title>
		<style>
			/* Basic page reset and theme */
			body,
			html {
				width: 100%;
				height: 100%;
				margin: 0;
				padding: 0;
				overflow: hidden;
				font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
					Helvetica, Arial, sans-serif;
				background-color: #1a1a1a;
				color: #f0f0f0;
			}

			/* Canvas fills the background */
			canvas {
				display: block;
				position: fixed;
				top: 0;
				left: 0;
				z-index: 1;
			}

			/* Main UI Panel */
			#ui-panel {
				position: absolute;
				top: 10px;
				left: 10px;
				z-index: 10;
				background: rgba(30, 30, 30, 0.85);
				backdrop-filter: blur(5px);
				border: 1px solid #444;
				border-radius: 8px;
				padding: 15px;
				min-width: 250px;
			}

			#ui-panel h2 {
				margin: 0 0 15px 0;
				font-size: 20px;
				border-bottom: 1px solid #555;
				padding-bottom: 10px;
			}

			.slider-group {
				margin-bottom: 10px;
			}

			.slider-group label {
				display: block;
				font-size: 13px;
				margin-bottom: 5px;
			}

			.slider-group span {
				float: right;
				font-family: "Courier New", Courier, monospace;
				font-size: 13px;
				background: #111;
				padding: 2px 5px;
				border-radius: 3px;
			}

			input[type="range"] {
				width: 100%;
				margin: 0;
			}

			.button-group {
				display: grid;
				grid-template-columns: 1fr 1fr 1fr;
				gap: 5px;
				margin-top: 15px;
			}

			button {
				padding: 8px 5px;
				font-size: 12px;
				font-weight: bold;
				border: 1px solid #666;
				background-color: #333;
				color: #eee;
				border-radius: 5px;
				cursor: pointer;
				transition: background-color 0.2s;
			}

			button:hover {
				background-color: #444;
			}

			button.active {
				background-color: #2a6a96;
				border-color: #5aa;
			}

			.answer-btn {
				padding: 10px 20px;
				color: white;
				border: none;
				border-radius: 5px;
				cursor: pointer;
				font-size: 14px;
				font-weight: bold;
				transition: transform 0.2s, opacity 0.3s;
			}

			.answer-btn:hover {
				transform: scale(1.05);
				opacity: 0.9;
			}

			.answer-btn:active {
				transform: scale(0.98);
			}

			/* Info Panel */
			#info-panel {
				position: absolute;
				top: 10px;
				right: 10px;
				z-index: 10;
				background: rgba(30, 30, 30, 0.85);
				backdrop-filter: blur(5px);
				border: 1px solid #444;
				border-radius: 8px;
				padding: 15px;
				width: 220px;
				font-size: 13px;
			}

			#info-panel h3 {
				margin: 0 0 10px 0;
				color: #ffff80;
			}

			#info-panel p {
				margin: 10px 0;
			}

			#info-panel ul {
				padding-left: 20px;
				margin: 10px 0;
			}

			/* Strength Meter */
			#strength-meter {
				position: absolute;
				bottom: 10px;
				left: 10px;
				z-index: 10;
				width: 250px;
				font-size: 13px;
			}

			#strength-meter label {
				margin-bottom: 5px;
				display: block;
			}

			#strength-bar-container {
				width: 100%;
				height: 20px;
				background: #333;
				border: 1px solid #666;
				border-radius: 5px;
				overflow: hidden;
			}

			#strength-bar {
				height: 100%;
				width: 50%; /* Default */
				background: linear-gradient(90deg, #ff8080, #ffff80, #80ff80);
				transition: width 0.3s, background-color 0.3s;
			}
		</style>
	</head>
	<body>
		<!-- The Three.js canvas -->
		<canvas id="c"></canvas>

		<!-- UI Panel for Controls -->
		<div id="ui-panel">
			<h2>Caf√© Wall Illusion Quiz</h2>
			
			<!-- Quiz Section -->
			<div id="quizSection">
				<p style="font-weight: bold; margin-top: 15px; font-size: 16px;">Are the horizontal lines parallel?</p>
				<div style="display: flex; gap: 10px; margin-top: 10px;">
					<button id="yesBtn" class="answer-btn" style="background-color: #28a745; width: 100%;">‚úì YES</button>
					<button id="noBtn" class="answer-btn" style="background-color: #dc3545; width: 100%;">‚úó NO</button>
				</div>
			</div>
			
			<!-- Feedback Section (hidden initially) -->
			<div id="feedbackSection" style="display: none;">
				<p id="feedbackText" style="font-weight: bold; margin-top: 15px; font-size: 16px;"></p>
				<button id="revealBtn" style="background-color: #28a745; color: white; width: 100%; padding: 10px; margin-top: 10px; font-weight: bold;">üëÅÔ∏è Reveal Truth</button>
			</div>
		</div>

		<!-- Info Panel - HIDDEN -->
		<div id="info-panel" style="display: none;">
			<h3>üß± Caf√© Wall Illusion</h3>
			<p>
				The horizontal lines appear slanted... but are they *really* straight?
			</p>
			<strong>üí° The illusion works best with:</strong>
			<ul>
				<li>Medium offset (~0.5)</li>
				<li>Thin gray lines (2-4px)</li>
				<li>Medium gray color (100-150)</li>
			</ul>
		</div>

		<!-- Illusion Strength Meter - HIDDEN -->
		<div id="strength-meter" style="display: none;">
			<label>Illusion Strength:</label>
			<div id="strength-bar-container">
				<div id="strength-bar"></div>
			</div>
		</div>

		<!-- Import Three.js -->
		<script
			async
			src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
		<script type="importmap">
			{
				"imports": {
					"three": "https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js"
				}
			}
		</script>

		<!-- Main Three.js Application Logic -->
		<script type="module">
			import * as THREE from "three";

			// --- Global Variables ---
			let scene, camera, renderer, clock;
			let patternGroup, gridGroup, refLinesGroup;

			// --- UI Element References ---
			const yesBtn = document.getElementById("yesBtn");
			const noBtn = document.getElementById("noBtn");
			const revealBtn = document.getElementById("revealBtn");
			const quizSection = document.getElementById("quizSection");
			const feedbackSection = document.getElementById("feedbackSection");
			const feedbackText = document.getElementById("feedbackText");

			// --- State Variables ---
			const config = {
				offset: 0.5,
				thickness: 2,
				gray: 128,
				width: 40,
				height: 30,
				slant: 0.05, // Lines are NOT parallel - they have a slant
			};
			let showReferenceLines = false;
			let showGridLines = false;
			let animationMode = false;
			let needsRedraw = false;
			let bricksVisible = true;  // New variable to control brick visibility 

			// --- Materials (re-used to save memory) ---
			const blackMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
			const whiteMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
			const lineMat = new THREE.MeshBasicMaterial({ color: 0x808080 });
			const gridMat = new THREE.LineBasicMaterial({
				color: 0x00ff00,
				transparent: true,
				opacity: 0.5,
			});
			const refMat = new THREE.LineBasicMaterial({
				color: 0xff0000,
				linewidth: 2, 
			});

			/**
			 * Helper function to clear all children from a Three.js Group
			 */
			function clearGroup(group) {
				while (group.children.length > 0) {
					const obj = group.children[0];
					group.remove(obj);
					if (obj.geometry) obj.geometry.dispose();
					if (obj.material) {
						if (Array.isArray(obj.material)) {
							obj.material.forEach((m) => {
								if (
									m !== blackMat &&
									m !== whiteMat &&
									m !== lineMat
								) {
									m.dispose();
								}
							});
						} else if (
							obj.material !== blackMat &&
							obj.material !== whiteMat &&
							obj.material !== lineMat
						) {
							obj.material.dispose();
						}
					}
				}
			}

			/**
			 * Main function to draw the caf√© wall pattern
			 */
			function drawCafeWallPattern() {
				clearGroup(patternGroup);
				
				// If bricks are hidden (after reveal), don't draw bricks or lines
				if (!bricksVisible) {
					// Only draw the slanted reference lines to show they're not parallel
					drawReferenceLines();
					return;
				}

				// Get config values
				let offsetRatio = parseFloat(config.offset);
				const lineThickness = parseFloat(config.thickness);
				const brickWidth = parseFloat(config.width);
				const brickHeight = parseFloat(config.height);
				const slantFactor = parseFloat(config.slant);

				// Set line color
				const grayVal = parseInt(config.gray) / 255;
				lineMat.color.setRGB(grayVal, grayVal, grayVal);

				// Define pattern boundaries
				const patternWidth = window.innerWidth;
				const patternHeight = window.innerHeight;
				const startX = -patternWidth / 2;
				const startY = patternHeight / 2;

				const rowHeight = brickHeight + lineThickness;
				const rows = Math.ceil(patternHeight / rowHeight);
				const cols = Math.ceil(patternWidth / brickWidth) + 2; // +2 for offset

				const brickGeo = new THREE.PlaneGeometry(brickWidth, brickHeight);

				for (let row = 0; row < rows; row++) {
					const y = startY - row * rowHeight - brickHeight / 2;

					// Draw mortar line
					if (lineThickness > 0 && row > 0) {
						const lineY = y + brickHeight / 2 + lineThickness / 2;
						
						// --- MODIFIED for slant ---
						const lineGeo = new THREE.ShapeGeometry(
							new THREE.Shape([
								new THREE.Vector2(-patternWidth / 2, lineY + (-patternWidth / 2) * slantFactor - lineThickness / 2),
								new THREE.Vector2( patternWidth / 2, lineY + ( patternWidth / 2) * slantFactor - lineThickness / 2),
								new THREE.Vector2( patternWidth / 2, lineY + ( patternWidth / 2) * slantFactor + lineThickness / 2),
								new THREE.Vector2(-patternWidth / 2, lineY + (-patternWidth / 2) * slantFactor + lineThickness / 2),
							])
						);
						const lineMesh = new THREE.Mesh(lineGeo, lineMat);
						lineMesh.position.set(0, 0, 0); // Position is baked into geo
						patternGroup.add(lineMesh);
					}

					// Draw bricks
					const xOffset =
						row % 2 === 1 ? offsetRatio * brickWidth : 0;

					for (let col = 0; col < cols; col++) {
						const x =
							startX +
							col * brickWidth -
							xOffset +
							brickWidth / 2;

						// --- MODIFIED for slant ---
						// Bricks must also follow the slanted line
						const brickY = y + x * slantFactor;
						const mat = col % 2 === 0 ? blackMat : whiteMat;
						const brick = new THREE.Mesh(brickGeo, mat);
						brick.position.set(x, brickY, 0); 
						patternGroup.add(brick);
					}
				}
			}

			/**
			 * Draw the green grid lines
			 */
			function drawGridLines() {
				clearGroup(gridGroup);
				gridGroup.visible = showGridLines;
				if (!showGridLines) return;

				const brickWidth = parseFloat(config.width);
				const brickHeight = parseFloat(config.height);
				const lineThickness = parseFloat(config.thickness);
				const rowHeight = brickHeight + lineThickness;
				const slantFactor = parseFloat(config.slant); // <-- NEW

				const width = window.innerWidth;
				const height = window.innerHeight;

				// Vertical lines (remain straight)
				const cols = Math.ceil(width / brickWidth) + 2;
				for (let i = -cols / 2; i <= cols / 2; i++) {
					const points = [
						new THREE.Vector3(i * brickWidth, height / 2, 1),
						new THREE.Vector3(i * brickWidth, -height / 2, 1),
					];
					const geo = new THREE.BufferGeometry().setFromPoints(points);
					gridGroup.add(new THREE.Line(geo, gridMat));
				}

				// Horizontal lines (must follow the slant!)
				const rows = Math.ceil(height / rowHeight);
				for (let i = -rows / 2; i <= rows / 2; i++) {
					const y = i * rowHeight;
					// --- MODIFIED for slant ---
					const yLeft = y + (-width / 2) * slantFactor;
					const yRight = y + (width / 2) * slantFactor;
					const points = [
						new THREE.Vector3(-width / 2, yLeft, 1),
						new THREE.Vector3(width / 2, yRight, 1),
					];
					const geo = new THREE.BufferGeometry().setFromPoints(points);
					gridGroup.add(new THREE.Line(geo, gridMat));
				}
			}

			/**
			 * Draw the red reference lines
			 */
			function drawReferenceLines() {
				clearGroup(refLinesGroup);
				refLinesGroup.visible = showReferenceLines;
				if (!showReferenceLines) return;

				const brickHeight = parseFloat(config.height);
				const lineThickness = parseFloat(config.thickness);
				const rowHeight = brickHeight + lineThickness;
				const slantFactor = parseFloat(config.slant); // <-- NEW

				const width = window.innerWidth;
				const height = window.innerHeight;
				const rows = Math.ceil(height / rowHeight);

				for (let i = 0; i < rows; i++) {
					const y =
						height / 2 -
						i * rowHeight -
						brickHeight -
						lineThickness / 2;
					
					// --- MODIFIED for slant ---
					// The "proof" lines must also be slanted to match
					const yLeft = y + (-width / 2 - 20) * slantFactor;
					const yRight = y + (width / 2 + 20) * slantFactor;
					const points = [
						new THREE.Vector3(-width / 2 - 20, yLeft, 2),
						new THREE.Vector3(width / 2 + 20, yRight, 2),
					];
					const geo = new THREE.BufferGeometry().setFromPoints(points);
					refLinesGroup.add(new THREE.Line(geo, refMat));
				}
			}

			/**
			 * Update the illusion strength meter
			 */
			function updateStrengthMeter() {
				const offset = parseFloat(config.offset);
				const thickness = parseFloat(config.thickness);
				const gray = parseFloat(config.gray);

				const offsetFactor = 1.0 - Math.abs(offset - 0.5) * 2;
				const thicknessFactor = Math.max(
					0,
					1.0 - Math.abs(thickness - 3) / 5
				);
				const grayFactor = 1.0 - Math.abs(gray - 128) / 128;

				const strength = Math.max(
					0,
					(offsetFactor + thicknessFactor + grayFactor) / 3
				);

				strengthBar.style.width = `${strength * 100}%`;

				if (strength > 0.7)
					strengthBar.style.backgroundColor = "#80ff80";
				else if (strength > 0.4)
					strengthBar.style.backgroundColor = "#ffff80";
				else strengthBar.style.backgroundColor = "#ff8080";
			}

			/**
			 * Main Init Function
			 */
			function init() {
				// --- Scene Setup ---
				scene = new THREE.Scene();
				clock = new THREE.Clock();

				// --- Renderer Setup ---
				const canvas = document.querySelector("#c");
				renderer = new THREE.WebGLRenderer({
					canvas,
					antialias: true,
				});
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.setPixelRatio(window.devicePixelRatio);

				// --- Camera Setup (Orthographic) ---
				const width = window.innerWidth;
				const height = window.innerHeight;
				camera = new THREE.OrthographicCamera(
					width / -2,
					width / 2,
					height / 2,
					height / -2,
					1,
					10
				);
				camera.position.z = 5;
				scene.add(camera);

				// --- Groups for managing objects ---
				patternGroup = new THREE.Group();
				gridGroup = new THREE.Group();
				refLinesGroup = new THREE.Group();
				scene.add(patternGroup, gridGroup, refLinesGroup);

				// --- Quiz Event Listeners ---
				yesBtn.addEventListener("click", () => answerQuestion('yes'));
				noBtn.addEventListener("click", () => answerQuestion('no'));
				revealBtn.addEventListener("click", revealTruth);

				// --- Window Resize ---
				window.addEventListener("resize", onWindowResize);

				// --- Initial Draw ---
				needsRedraw = true;
				animate();
			}

			/**
			 * Handle Window Resize
			 */
			function onWindowResize() {
				const width = window.innerWidth;
				const height = window.innerHeight;

				camera.left = -width / 2;
				camera.right = width / 2;
				camera.top = height / 2;
				camera.bottom = -height / 2;
				camera.updateProjectionMatrix();

				renderer.setSize(width, height);
				renderer.setPixelRatio(window.devicePixelRatio);

				needsRedraw = true;
			}

			/**
			 * Quiz Functions
			 */
			function answerQuestion(answer) {
				// Hide quiz buttons
				quizSection.style.display = 'none';
				
				// Show feedback
				feedbackSection.style.display = 'block';
				
				if (answer === 'no') {
					feedbackText.innerHTML = '‚úÖ <span style="color: green;">CORRECT!</span> The horizontal lines are NOT parallel!';
					feedbackText.style.color = 'green';
				} else {
					feedbackText.innerHTML = '‚ùå <span style="color: red;">INCORRECT!</span> The lines are actually NOT parallel - they have a slight slant!';
					feedbackText.style.color = 'red';
				}
			}

			function revealTruth() {
				// Hide all bricks and mortar lines
				bricksVisible = false;
				showReferenceLines = true;
				needsRedraw = true;
				
				// Update button
				revealBtn.textContent = '‚úì Revealed!';
				revealBtn.style.background = '#6c757d';
				revealBtn.disabled = true;
				
				// Send message to parent window
				setTimeout(() => {
					window.parent.postMessage({ quizPassed: 'cafeWall' }, '*');
				}, 500);
			}

			/**
			 * Main Animation Loop
			 */
			function animate() {
				requestAnimationFrame(animate);

				if (needsRedraw) {
					drawCafeWallPattern();
					drawGridLines();
					drawReferenceLines();
					needsRedraw = false;
				}

				renderer.render(scene, camera);
			}

			// Start the application
			init();
		</script>
	</body>
</html>

